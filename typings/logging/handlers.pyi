"""
This type stub file was generated by pyright.
"""

import datetime
import http.client
import ssl
import sys
from collections.abc import Callable
from logging import FileHandler, Handler, LogRecord
from re import Pattern
from socket import SocketKind, socket
from threading import Thread
from typing import Any, ClassVar, Final, Protocol, TypeVar

from _typeshed import ReadableBuffer, StrPath

_T = TypeVar("_T")
DEFAULT_TCP_LOGGING_PORT: Final[int]
DEFAULT_UDP_LOGGING_PORT: Final[int]
DEFAULT_HTTP_LOGGING_PORT: Final[int]
DEFAULT_SOAP_LOGGING_PORT: Final[int]
SYSLOG_UDP_PORT: Final[int]
SYSLOG_TCP_PORT: Final[int]
class WatchedFileHandler(FileHandler):
    dev: int
    ino: int
    if sys.version_info >= (3, 9):
        def __init__(self, filename: StrPath, mode: str = ..., encoding: str | None = ..., delay: bool = ..., errors: str | None = ...) -> None:
            ...
        
    else:
        ...
    def reopenIfNeeded(self) -> None:
        ...
    


class BaseRotatingHandler(FileHandler):
    namer: Callable[[str], str] | None
    rotator: Callable[[str, str], None] | None
    if sys.version_info >= (3, 9):
        def __init__(self, filename: StrPath, mode: str, encoding: str | None = ..., delay: bool = ..., errors: str | None = ...) -> None:
            ...
        
    else:
        ...
    def rotation_filename(self, default_name: str) -> str:
        ...
    
    def rotate(self, source: str, dest: str) -> None:
        ...
    


class RotatingFileHandler(BaseRotatingHandler):
    maxBytes: int
    backupCount: int
    if sys.version_info >= (3, 9):
        def __init__(self, filename: StrPath, mode: str = ..., maxBytes: int = ..., backupCount: int = ..., encoding: str | None = ..., delay: bool = ..., errors: str | None = ...) -> None:
            ...
        
    else:
        ...
    def doRollover(self) -> None:
        ...
    
    def shouldRollover(self, record: LogRecord) -> int:
        ...
    


class TimedRotatingFileHandler(BaseRotatingHandler):
    when: str
    backupCount: int
    utc: bool
    atTime: datetime.time | None
    interval: int
    suffix: str
    dayOfWeek: int
    rolloverAt: int
    extMatch: Pattern[str]
    if sys.version_info >= (3, 9):
        def __init__(self, filename: StrPath, when: str = ..., interval: int = ..., backupCount: int = ..., encoding: str | None = ..., delay: bool = ..., utc: bool = ..., atTime: datetime.time | None = ..., errors: str | None = ...) -> None:
            ...
        
    else:
        ...
    def doRollover(self) -> None:
        ...
    
    def shouldRollover(self, record: LogRecord) -> int:
        ...
    
    def computeRollover(self, currentTime: int) -> int:
        ...
    
    def getFilesToDelete(self) -> list[str]:
        ...
    


class SocketHandler(Handler):
    host: str
    port: int | None
    address: tuple[str, int] | str
    sock: socket | None
    closeOnError: bool
    retryTime: float | None
    retryStart: float
    retryFactor: float
    retryMax: float
    def __init__(self, host: str, port: int | None) -> None:
        ...
    
    def makeSocket(self, timeout: float = ...) -> socket:
        ...
    
    def makePickle(self, record: LogRecord) -> bytes:
        ...
    
    def send(self, s: ReadableBuffer) -> None:
        ...
    
    def createSocket(self) -> None:
        ...
    


class DatagramHandler(SocketHandler):
    def makeSocket(self) -> socket:
        ...
    


class SysLogHandler(Handler):
    LOG_EMERG: int
    LOG_ALERT: int
    LOG_CRIT: int
    LOG_ERR: int
    LOG_WARNING: int
    LOG_NOTICE: int
    LOG_INFO: int
    LOG_DEBUG: int
    LOG_KERN: int
    LOG_USER: int
    LOG_MAIL: int
    LOG_DAEMON: int
    LOG_AUTH: int
    LOG_SYSLOG: int
    LOG_LPR: int
    LOG_NEWS: int
    LOG_UUCP: int
    LOG_CRON: int
    LOG_AUTHPRIV: int
    LOG_FTP: int
    if sys.version_info >= (3, 9):
        LOG_NTP: int
        LOG_SECURITY: int
        LOG_CONSOLE: int
        LOG_SOLCRON: int
        ...
    LOG_LOCAL0: int
    LOG_LOCAL1: int
    LOG_LOCAL2: int
    LOG_LOCAL3: int
    LOG_LOCAL4: int
    LOG_LOCAL5: int
    LOG_LOCAL6: int
    LOG_LOCAL7: int
    address: tuple[str, int] | str
    unixsocket: bool
    socktype: SocketKind
    ident: str
    append_nul: bool
    facility: int
    priority_names: ClassVar[dict[str, int]]
    facility_names: ClassVar[dict[str, int]]
    priority_map: ClassVar[dict[str, str]]
    def __init__(self, address: tuple[str, int] | str = ..., facility: str | int = ..., socktype: SocketKind | None = ...) -> None:
        ...
    
    if sys.version_info >= (3, 11):
        def createSocket(self) -> None:
            ...
        
    def encodePriority(self, facility: int | str, priority: int | str) -> int:
        ...
    
    def mapPriority(self, levelName: str) -> str:
        ...
    


class NTEventLogHandler(Handler):
    def __init__(self, appname: str, dllname: str | None = ..., logtype: str = ...) -> None:
        ...
    
    def getEventCategory(self, record: LogRecord) -> int:
        ...
    
    def getEventType(self, record: LogRecord) -> int:
        ...
    
    def getMessageID(self, record: LogRecord) -> int:
        ...
    


class SMTPHandler(Handler):
    mailhost: str
    mailport: int | None
    username: str | None
    password: str
    fromaddr: str
    toaddrs: list[str]
    subject: str
    secure: tuple[()] | tuple[str] | tuple[str, str] | None
    timeout: float
    def __init__(self, mailhost: str | tuple[str, int], fromaddr: str, toaddrs: str | list[str], subject: str, credentials: tuple[str, str] | None = ..., secure: tuple[()] | tuple[str] | tuple[str, str] | None = ..., timeout: float = ...) -> None:
        ...
    
    def getSubject(self, record: LogRecord) -> str:
        ...
    


class BufferingHandler(Handler):
    capacity: int
    buffer: list[LogRecord]
    def __init__(self, capacity: int) -> None:
        ...
    
    def shouldFlush(self, record: LogRecord) -> bool:
        ...
    


class MemoryHandler(BufferingHandler):
    flushLevel: int
    target: Handler | None
    flushOnClose: bool
    def __init__(self, capacity: int, flushLevel: int = ..., target: Handler | None = ..., flushOnClose: bool = ...) -> None:
        ...
    
    def setTarget(self, target: Handler | None) -> None:
        ...
    


class HTTPHandler(Handler):
    host: str
    url: str
    method: str
    secure: bool
    credentials: tuple[str, str] | None
    context: ssl.SSLContext | None
    def __init__(self, host: str, url: str, method: str = ..., secure: bool = ..., credentials: tuple[str, str] | None = ..., context: ssl.SSLContext | None = ...) -> None:
        ...
    
    def mapLogRecord(self, record: LogRecord) -> dict[str, Any]:
        ...
    
    if sys.version_info >= (3, 9):
        def getConnection(self, host: str, secure: bool) -> http.client.HTTPConnection:
            ...
        


class _QueueLike(Protocol[_T]):
    def get(self) -> _T:
        ...
    
    def put_nowait(self, item: _T, /) -> None:
        ...
    


class QueueHandler(Handler):
    queue: _QueueLike[Any]
    def __init__(self, queue: _QueueLike[Any]) -> None:
        ...
    
    def prepare(self, record: LogRecord) -> Any:
        ...
    
    def enqueue(self, record: LogRecord) -> None:
        ...
    


class QueueListener:
    handlers: tuple[Handler, ...]
    respect_handler_level: bool
    queue: _QueueLike[Any]
    _thread: Thread | None
    def __init__(self, queue: _QueueLike[Any], *handlers: Handler, respect_handler_level: bool = ...) -> None:
        ...
    
    def dequeue(self, block: bool) -> LogRecord:
        ...
    
    def prepare(self, record: LogRecord) -> Any:
        ...
    
    def start(self) -> None:
        ...
    
    def stop(self) -> None:
        ...
    
    def enqueue_sentinel(self) -> None:
        ...
    
    def handle(self, record: LogRecord) -> None:
        ...
    


